## 1. CashMember 도입

- [CashMember](src\01_CashMember\CashMember.java) : Cash 테이블에 있는 Member 관련 데이터를 별도의 CashMember 테이블로 분리하여 관리
- [CashMemberRepository](src\01_CashMember\CashMemberRepository.java) : CashMember 데이터 접근 및 관리
- [CashEventListener](src\01_CashMember\CashEventListener.java) : Member 관련 이벤트 발생 시 CashMember 업데이트 처리
- [CashFacade](src\01_CashMember\CashFacade.java) : CashMember와 Member 데이터 동기화

---

## 2. Wallet 도입 (CashWallet)

- [BaseManualIdAndTime](src\02_CashWallet\base\BaseManualIdAndTime.java) : 수동 ID 및 생성/수정 시간 관리를 위한 베이스 클래스
- [Wallet](src\02_CashWallet\Wallet.java) : CashMember와 1:1 관계인 지갑 생성
    - CashMember에 wallet 필드를 추가하지 않은 이유: 지갑은 추후 비관적인 락을 걸어서 가져와야 하는 경우가 있을 수 있기 때문에
- [WalletRepository](src\02_CashWallet\WalletRepository.java) : Wallet 데이터 접근 및 관리
- [CashEventListener](src\02_CashWallet\CashEventListener.java) : MemberJoinedEvent 발생 시 Wallet 생성 처리
- [CashFacade](src\02_CashWallet\CashFacade.java) : createWallet 메서드 추가

---

## 3. Cash 관련 데이터 초기화
- [Wallet](src\03_CashDataInit\Wallet.java) : Wallet에는 현재 상태인 balance 필드만 존재
- [CashLog](src\03_CashDataInit\CashLog.java) : Cash 변경 이력을 기록하는 CashLog 엔티티 추가
- [CashFacade](src\03_CashDataInit\CashFacade.java) : findMemberByUserName(), findWalletByHoder() 메서드 추가
- [CashDataInit](src\03_CashDataInit\CashDataInit.java) : Wallet 초기화
- [WalletRepository](src\03_CashDataInit\WalletRepository.java) : findByHolder() 메서드 추가

---

## 4. Cash 모듈 리팩토링

### Facade에 직접 구현된 기능들을 UseCase로 분리

* [CashFacade](src\04_Cash_Refactoring\CashFacade.java) : 구현로직 없이 유즈케이스 호출로 구성

* UseCase : 비즈니스 로직 구현
  * [CashCreateWalletUseCase](src\04_Cash_Refactoring\CashCreateWalletUseCase.java) : 지갑 생성 유즈케이스
  * [CashSyncMemberUseCase](src\04_Cash_Refactoring\CashSyncMemberUseCase.java) : 멤버 동기화 유즈케이스  

* [CashSupport](src\04_Cash_Refactoring\usecase\CashSupport.java) : UseCase에서 중복되는 코드인 findBy 메서드 모음

### CashEventListener에 있는 비지니스 로직을 이벤트를 사용하여 제거

- [CashMemberDto](src\04_Cash_Refactoring\CashMemberDto.java) : CashMember 관련 DTO
- [CashMemberCreatedEvent](src\04_Cash_Refactoring\CashMemberCreatedEvent.java) : CashMember 생성 이벤트
- [CashSyncMemberUseCase](src\04_Cash_Refactoring\CashSyncMemberUseCase.java) : CashMember 생성 후 CashMemberCreatedEvent 발행
- [CashEventListener](src\04_Cash_Refactoring\CashEventListener.java) : CashMemberCreatedEvent 리스너 추가
- [CashFacade](src\04_Cash_Refactoring\CashFacade.java) : CashMember를 CashMemberDto로 변환
- [CashCreateWalletUseCase](src\04_Cash_Refactoring\CashCreateWalletUseCase.java) : CashMemberCreatedEvent 수신 후 Wallet 생성

---

## 5. Post 모듈 리팩토링 - Facade에 직접 구현된 기능들을 UseCase로 분리

- [PostFacade](src\05_Post_Refactoring\PostFacade.java) : 구현로직 없이 유즈케이스 호출로 구성
- [PostSyncMemberUseCase](src\05_Post_Refactoring\PostSyncMemberUseCase.java) : Post 모듈에서 Member 동기화 유즈케이스
- [PostSupport](src\05_Post_Refactoring\PostSupport.java) : UseCase에서 중복되는 메서드 모음

---

## 6. Member 모듈 리팩토링 - Facade에 직접 구현된 기능들을 UseCase로 분리

- [MemberFacade](src\06_Member_Refactoring\MemberFacade.java) : 구현로직 없이 유즈케이스 호출로 구성
- [MemberGetRandomSecureTipUseCase](src\06_Member_Refactoring\MemberGetRandomSecureTipUseCase.java) : Member 모듈에서 랜덤 보안 팁 조회 유즈케이스
- [MemberSupport](src\06_Member_Refactoring\MemberSupport.java) : UseCase에서 중복되는 메서드 모음

---

## 7. Market 모듈 추가 - MarketMember 구현

- [MarketMember](src\07_MarketModule\MarketMember.java) : Market 모듈에서 Member 관련 데이터 관리
- [MarketMemberRepository](src\07_MarketModule\MarketMemberRepository.java) : MarketMember 데이터 접근 및 관리
- [MarketEventListener](src\07_MarketModule\MarketEventListener.java) : Member 관련 이벤트 발생 시 MarketMember 업데이트 처리
- [MarketFacade](src\07_MarketModule\MarketFacade.java) : MarketSyncMemberUseCase 호출
- [MarketSyncMemberUseCase](src\07_MarketModule\MarketSyncMemberUseCase.java) : Market 모듈에서 Member 동기화 유즈케이스

---

## 8. 글 조회를 위해서 PostApiClient 구현

- [PostApiClient](src\08_PostApiClient\PostApiClient.java) : Post 모듈의 글 조회 API 클라이언트
- [PostDto](src\08_PostApiClient\PostDto.java) : Post 모듈의 글 관련 DTO
- [PostFacade](src\08_PostApiClient\PostFacade.java) : findByOrderByIdDesc() 메서드 추가
- [PostSupport](src\08_PostApiClient\PostSupport.java) : findByOrderByIdDesc() 메서드 추가
- [PostRepository](src\08_PostApiClient\PostRepository.java) : findByOrderByIdDesc() 메서드 추가
- [MarketDataInit](src\08_PostApiClient\MarketDataInit.java) : Market 모듈에서 PostApiClient를 사용하여 글 데이터 초기화
- [ApiV1PostController](src\08_PostApiClient\ApiV1PostController.java) : 글 조회 API 구현

---

## 9. 글 6개로부터 상품 6개 생성

- [MarketDataInit](src\09_CreateMarketFromPost\MarketDataInit.java) : Market 모듈에서 PostApiClient를 사용하여 글 6개로부터 상품 6개 생성
- [Product](src\09_CreateMarketFromPost\Product.java) : Market 모듈의 상품 엔티티
- [ProductRepository](src\09_CreateMarketFromPost\ProductRepository.java) : Product 데이터 접근 및 관리
- [MarketFacade](src\09_CreateMarketFromPost\MarketFacade.java) : createProduct 메서드 추가
- [MarketCreateProductUseCase](src\09_CreateMarketFromPost\MarketCreateProductUseCase.java) : 글로부터 상품 생성 유즈케이스
- [MarketSupport](src\09_CreateMarketFromPost\MarketSupport.java) : 중복되는 메서드 모음

---

## 10. MarketMember와 1:1 관계인 장바구니 생성, 장바구니 품목 추가

[0033](https://github.com/jhs512/p-14116-1/commit/0033#diff-98dc624a0887f93a6a50a768265e924fef90ced30939a68d9e3b8b9cdb2b6352)


### 1단계: 회원 가입/수정 시 (외부 이벤트 수신)
1. **`MarketEventListener.handle(MemberJoinedEvent/MemberModifiedEvent)`**
   → Member 도메인에서 발생한 회원 가입/수정 이벤트를 수신하여 Market 도메인에 동기화 요청

2. **`MarketFacade.syncMember()`**
   → Market 도메인의 진입점으로, UseCase로 위임하는 파사드 역할

3. **`MarketSyncMemberUseCase.syncMember()`**
   → MemberDto를 MarketMember 엔티티로 변환 후 저장, 신규 회원이면 `MarketMemberCreatedEvent` 발행

### 2단계: MarketMember 생성 후 장바구니 자동 생성
4. **`MarketEventListener.handle(MarketMemberCreatedEvent)`**
   → MarketMember 생성 이벤트를 수신하여 장바구니 생성 요청

5. **`MarketFacade.createCart()`**
   → 장바구니 생성 UseCase로 위임

6. **`MarketCreateCartUseCase.createCart()`**
   → 해당 회원의 Cart 엔티티를 생성하고 저장

### 3단계: 애플리케이션 시작 시 초기 데이터 생성
7. **`MarketDataInit.makeBaseProducts()`**
   → ApplicationRunner로 실행되어 테스트용 상품 데이터 6개 생성


### 보조 클래스들
- **`MarketSupport`**: Repository 조회 로직을 모아둔 헬퍼 서비스
- **`Cart / CartItem`**: 장바구니와 장바구니 항목 엔티티
- **`CartRepository`**: Cart JPA 저장소 인터페이스
- **`MarketMemberDto`**: MarketMember를 다른 컨텍스트로 전달할 때 사용하는 DTO
- **`MarketMemberCreatedEvent`**: MarketMember 생성을 알리는 도메인 이벤트

---

## 11. 주문 생성

[0034](https://github.com/jhs512/p-14116-1/commit/0034#diff-09aad119f6df89c61db4d05e4d1c391963ed032e12027f7df170965fcd434a7b)

애플리케이션 시작 시 `MarketDataInit`의 `ApplicationRunner`가 실행되면서 다음 순서로 초기화가 진행돼요.

### 1단계: makeBaseProducts() - 상품 생성

```
MarketFacade.productsCount() 
  → MarketSupport.countProducts() 
    → ProductRepository.count()
```

상품이 없으면 `PostApiClient`에서 게시글을 가져와서 상품으로 등록해요.

```
MarketFacade.findMemberByUsername() → MarketSupport → MarketMemberRepository
MarketFacade.createProduct() → MarketCreateProductUseCase → ProductRepository.save()
```

### 2단계: makeBaseCartItems() - 장바구니에 상품 추가

```
MarketFacade.findMemberByUsername() → 회원 조회
MarketFacade.findCartByBuyer() → MarketSupport → CartRepository
MarketFacade.findProductById() → MarketSupport → ProductRepository
Cart.addItem() → CartItem 생성 후 리스트에 추가
```

### 3단계: makeBaseOrders() - 주문 생성

```
MarketFacade.ordersCount() → MarketSupport.countOrders() → OrderRepository.count()
MarketFacade.createOrder(cart) 
  → MarketCreateOrderUseCase.createOrder()
    → new Order(cart)  // Cart의 아이템들로 Order 생성
      → Order.addItem() → new OrderItem()
    → OrderRepository.save()
    → cart.clearItems()  // 장바구니 비우기
```

---

## 12. 주문 결제처리

[0035](https://github.com/jhs512/p-14116-1/commit/0035#diff-a2f36ef35acb7ef22152e8f700db567667d344587aaab792e76e0453d3dcc7b4)

이 코드는 주문 결제 시스템으로, Market(마켓)과 Cash(캐시/지갑) 두 개의 Bounded Context 간 이벤트 기반 통신을 구현하고 있어.

### 전체 실행 흐름

```
주문 결제 요청 → Market에서 이벤트 발행 → Cash에서 결제 처리 → 결과 이벤트 발행 → Market에서 주문 상태 업데이트
```

### 1단계: 결제 요청 시작

[**MarketDataInit.java**](src\12_Payment\MarketDataInit.java) - 애플리케이션 시작 시 테스트 데이터 생성
```java
marketFacade.requestPayment(order1, 0);  // pgPaymentAmount = 0 (PG 결제 없이 캐시로만)
```

[**MarketFacade.java**](src\12_Payment\MarketFacade.java) → [**Order.java**](src\12_Payment\Order.java) 호출
```java
order.requestPayment(pgPaymentAmount);
```

**Order.java** - 결제 요청 처리 및 이벤트 발행
```java
public void requestPayment(long pgPaymentAmount) {
    requestPaymentDate = LocalDateTime.now();
    publishEvent(new MarketOrderPaymentRequestedEvent(new OrderDto(this), pgPaymentAmount));
}
```

### 2단계: Cash 도메인에서 이벤트 수신

[**CashEventListener**](src\12_Payment\CashEventListener.java)가 `MarketOrderPaymentRequestedEvent`를 수신해서:

[**CashFacade.java**](src\12_Payment\CashFacade.java) → [**CashCompleteOrderPaymentUseCase.java**](src\12_Payment\CashCompleteOrderPaymentUseCase.java) 호출

### 3단계: 결제 처리 로직

**CashCompleteOrderPaymentUseCase.java** - 핵심 결제 로직
```java
public void handle(MarketOrderPaymentRequestedEvent event) {
    // 1. 고객 지갑과 홀딩 지갑 조회
    Wallet customerWallet = cashSupport.findWalletByHolderId(customerId);
    Wallet holdingWallet = cashSupport.findHoldingWallet();  // HOLDING_MEMBER_ID = 2
    
    // 2. PG 결제 금액이 0보다 큰 경우에, 즉 실제로 PG 결제가 있었을 때 먼저 충전
    if (pgPaymentAmount > 0) {
        customerWallet.credit(pgPaymentAmount, 충전__PG결제_토스페이먼츠, ...);
    }
    
    // 3. 잔액 확인 후 결제 처리
    if (잔액 >= 주문금액) {
        customerWallet.debit(주문금액);      // 고객 지갑에서 차감
        holdingWallet.credit(주문금액);      // 홀딩 지갑으로 이동
        eventPublisher.publish(new CashOrderPaymentSucceededEvent(...));  // 성공
    } else {
        eventPublisher.publish(new CashOrderPaymentFailedEvent(...));     // 실패
    }
}
```


### 4단계: Market 도메인에서 결과 이벤트 수신

[**MarketEventListener.java**](src\12_Payment\MarketEventListener.java) - Cash 도메인 이벤트 구독
```java
@TransactionalEventListener(phase = AFTER_COMMIT)
@Transactional(propagation = REQUIRES_NEW)
public void handle(CashOrderPaymentSucceededEvent event) {
    marketFacade.handle(event);  // 성공 시
}

public void handle(CashOrderPaymentFailedEvent event) {
    marketFacade.handle(event);  // 실패 시
}
```

### 5단계: 주문 상태 최종 업데이트

**성공 시** → [**MarketCompleteOrderPaymentUseCase.java**](src\12_Payment\MarketCompleteOrderPaymentUseCase.java)
```java
public void handle(CashOrderPaymentSucceededEvent event) {
    Order order = orderRepository.findById(event.getOrder().getId()).get();
    order.completePayment();  // paymentDate = now()
}
```

**실패 시** → [**MarketCancelOrderRequestPaymentUseCase.java**](src\12_Payment\MarketCancelOrderRequestPaymentUseCase.java)
```java
public void handle(CashOrderPaymentFailedEvent event) {
    Order order = orderRepository.findById(event.getOrder().getId()).get();
    order.cancelRequestPayment();  // requestPaymentDate = null
}
```

### 주요 컴포넌트 역할 정리

| 클래스 | 역할 |
|--------|------|
| **MarketFacade / CashFacade** | 각 도메인의 진입점, 트랜잭션 관리 |
| **MarketSupport / CashSupport** | 조회 전용 헬퍼 (Repository 래핑) |
| **EventListener** | 이벤트 수신 후 Facade 호출 |
| **UseCase** | 단일 책임의 비즈니스 로직 |
| **Event (DTO)** | 도메인 간 통신용 불변 객체 |
| **CashPolicy** | 정책 상수 (홀딩 계정 ID 등) |

이 구조는 **이벤트 소싱 + CQRS 패턴**의 일부를 적용해서, 두 Bounded Context가 직접 의존하지 않고 이벤트로 느슨하게 결합되어 있어.

---

## 13. 토스 페이먼츠 연동

[0036](https://github.com/jhs512/p-14116-1/commit/0036)

토스 페이먼츠 테스트 주의사항
- `.env`에 시크릿 키 입력해주셔야 합니다.
- 결제 시도 시에는 본인의 클라이언트 키를 입력해야 합니다.

### 1. [ApiV1OrderController](src\13_Toss_Payments\ApiV1OrderController.java) - 진입점

클라이언트가 `POST /api/v1/market/orders/{id}/payment/confirm/by/tossPayments`를 호출하면 시작돼.

```
요청 본문: { paymentKey, orderId, amount }
```

**검증 순서:**
1. 주문 조회 → `marketFacade.findOrderById(id)`
2. 주문 상태 검증 (취소됨? 진행중? 이미 결제됨?)
3. 잔액 검증 → `cashApiClient.getBalanceByHolderId()`로 지갑 잔액 조회
4. 주문번호 일치 검증

### 2. [CashApiClient](src\13_Toss_Payments\CashApiClient.java) - 지갑 잔액 조회

내부 API(`localhost:8080/api/v1/cash/wallets/by-holder/{holderId}`)를 호출해서 사용자 지갑 정보를 가져와.

```java
getBalanceByHolderId(buyerId) 
  → getItemByHolderId() → WalletDto 반환
  → walletDto.getBalance() → 잔액 반환
```

### 3. [WalletDto](src\13_Toss_Payments\WalletDto.java) - 지갑 데이터 전송 객체

CashApiClient가 받아오는 JSON 응답을 매핑하는 DTO. `@JsonCreator`로 역직렬화 지원.

### 4. [TossPaymentsService](src\13_Toss_Payments\TossPaymentsService.java) - 토스 결제 승인

토스페이먼츠 API(`api.tosspayments.com/v1/payments/confirm`)에 결제 승인 요청을 보내.

```java
confirmCardPayment(paymentKey, orderId, amount)
  → POST 요청 with Basic Auth
  → 성공: Map<String, Object> 반환
  → 실패: DomainException 던짐
```

### 5. [Order](src\13_Toss_Payments\Order.java) - 도메인 엔티티

결제 요청 처리 후 상태 변경:

```java
marketFacade.requestPayment(order, amount)
  → order.requestPayment(pgPaymentAmount)
    → requestPaymentDate = now()
    → MarketOrderPaymentRequestedEvent 발행
```

### 전체 흐름 다이어그램

```
Client
  │
  ▼
ApiV1OrderController
  │
  ├─► MarketFacade.findOrderById() → Order 조회
  │
  ├─► CashApiClient.getBalanceByHolderId()
  │      │
  │      └─► 내부 Cash API 호출 → WalletDto → 잔액 확인
  │
  ├─► TossPaymentsService.confirmCardPayment()
  │      │
  │      └─► 토스페이먼츠 API 호출 → 결제 승인
  │
  └─► MarketFacade.requestPayment()
         │
         └─► Order.requestPayment() → 이벤트 발행
```

**핵심 포인트:** 토스 결제 승인이 먼저 완료된 후에 `requestPayment()`가 호출되는데, 이 시점에서 도메인 이벤트(`MarketOrderPaymentRequestedEvent`)가 발행돼서 후속 처리(캐시 차감, 주문 완료 등)가 비동기로 진행될 것으로 보여.

---

## 14. 각종 설정들을 application.yml 파일에 모아두기

[application.yml](src\14_Application_Yml\application.yml)
- global.internalBackUrl
- member.password.changeDays
- product.payoutRate

---

## 15. 리팩토링
1. 이벤트 객체 수신 코드가 Facade와 UseCase에 침투해 있는것을 제거
   - [0038](https://github.com/jhs512/p-14116-1/commit/0038)

2. shared 모듈에서 boundedContext 모듈을 참조하지 않도록 수정, 각 엔티티 클래스에 toDto 메서드 구현
   - [0039](https://github.com/jhs512/p-14116-1/commit/0039)

3. 인터페이스 도입하여 개발자 마음속의 규격을 코드로 드러내기
   - [0040](https://github.com/jhs512/p-14116-1/commit/0040)